<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Data Binding | Sina Iravanian]]></title>
  <link href="http://sinairv.github.io/blog/categories/data-binding/atom.xml" rel="self"/>
  <link href="http://sinairv.github.io/"/>
  <updated>2015-05-18T00:57:01+10:00</updated>
  <id>http://sinairv.github.io/</id>
  <author>
    <name><![CDATA[Sina Iravanian]]></name>
    <email><![CDATA[sina.iravanian@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Handy Extensions for INotifyPropertyChanged]]></title>
    <link href="http://sinairv.github.io/blog/2015/01/15/handy-extensions-for-inotifypropertychanged/"/>
    <updated>2015-01-15T01:22:39+11:00</updated>
    <id>http://sinairv.github.io/blog/2015/01/15/handy-extensions-for-inotifypropertychanged</id>
    <content type="html"><![CDATA[<p>I recently created a <a href="https://github.com/sinairv/INPC-Extensions">library</a> that contains some handy extensions for <code>INotifyPropertyChanged</code> interface (aka INPC). To start using the library, add the following to the top of your C# code:</p>

<p><code>csharp
using NotifyPropertyChangedExtensions;
</code></p>

<h4 id="how-to-easily-raise-inpc-in-a-refactor-friendly-way">How to easily raise INPC in a refactor friendly way</h4>

<p>```csharp
public class MyClass : INotifyPropertyChanged
{
    private int _number;</p>

<pre><code>public int Number
{
    get { return _number; }
    set 
    { 
        if(_number != value)
        {
            _number = value; 
            this.RaisePropertyChanged(() =&gt; Number); 
        }
    }
}

public event PropertyChangedEventHandler PropertyChanged; } ```
</code></pre>

<h4 id="how-to-easily-handle-listen-to-inpc-in-a-refactor-friendly-way">How to easily handle (listen to) INPC in a refactor friendly way</h4>

<p>```csharp
MyClass myObject = …;</p>

<p>myObject.HandleOnPropertyChanged(src =&gt; src.Number, sender =&gt;
    {
        Console.WriteLine(“Number changed to {0}”, sender.Number);
    });
```</p>

<h4 id="how-to-do-one-way-binding-from-a-class-that-implements-inpc">How to do one-way binding from a class that implements INPC</h4>

<p>```csharp
var source = new MyClass();
var target = new TargetClass();</p>

<p>source.BindProperty(src =&gt; src.Number, target, t =&gt; t.Num);</p>

<p>source.Number = 10;
Console.WriteLine(target.Num); // 10
```</p>

<p>You can negate a boolean property while binding it. I use it a lot and find it very handy.</p>

<p>```csharp
source.BindProperty(src =&gt; src.IsActive, target, t =&gt; !t.IsDeleted);</p>

<p>source.IsActive = false;
Console.WriteLine(target.IsDeleted); // True
```</p>

<p>You can bind primitive data-types in source class to <code>Nullable</code> primitive data-types in the target class, and vice versa. </p>

<p><code>csharp
source.BindProperty(src =&gt; src.Number, target, t =&gt; t.NullableNumber);
</code></p>

<p>What happens if source is <code>null</code>, and the target is not <code>Nullable</code>? </p>

<p>The default behavior is to update target with default value of that type:</p>

<p>```csharp
target.Number = 10;
source.BindProperty(src =&gt; src.NullableNumber, target, t =&gt; t.Number);</p>

<p>source.NullableNumber = null;
Console.WriteLine(target.Number); // 0
```</p>

<p>You can also choose not to update target if source becomes <code>null</code>:</p>

<p>```csharp
target.Number = 10;
source.BindProperty(src =&gt; src.NullableNumber, target, t =&gt; t.Number, 
    BindPropertyOptions.DontUpdateWhenSourceIsNullAndTargetIsNotNullable);</p>

<p>source.NullableNumber = null;
Console.WriteLine(target.Number); // still 10
```</p>

<h4 id="how-to-find-more-information-about-this-library">How to find more information about this library?</h4>

<p>At the moment the best way to find out how this library works is by reading the unit tests or at least their titles.</p>

<p><a href="https://github.com/sinairv/INPC-Extensions">INPC-Extensions</a> is now hosted in GitHub and is licensed under MIT.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Make More Refactoring Friendly Data-bindings With C# 5]]></title>
    <link href="http://sinairv.github.io/blog/2012/11/01/how-to-make-more-refactoring-friendly-data-bindings-with-c-number-5/"/>
    <updated>2012-11-01T20:46:29+11:00</updated>
    <id>http://sinairv.github.io/blog/2012/11/01/how-to-make-more-refactoring-friendly-data-bindings-with-c-number-5</id>
    <content type="html"><![CDATA[<p>Imagine that we want to create a <code>Person</code> business object for whose properties we desire a two-way data binding. The source-to-target data-binding can be triggered by implementing <code>INotifyPropertyChanged</code> interface, like this:</p>

<p>```csharp
public class Person : INotifyPropertyChanged
{
    private string _name;
    private double _age;</p>

<pre><code>public string Name 
{
    get
    {
        return _name;
    }

    set
    {
        if (value != _name)
        {
            _name = value;
            OnPropertyChanged("Name");
        }
    }
}

public double Age 
{
    get
    {
        return _age;
    }

    set
    {
        if (_age != value)
        {
            _age = value;
            OnPropertyChanged("Age");
        }
    }
}

public event PropertyChangedEventHandler PropertyChanged;

private void OnPropertyChanged(string propertyName)
{
    if (PropertyChanged != null)
    {
        PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
    }
} } ```
</code></pre>

<p>See how the setters pass the property name in a <code>string</code>. This is not nice, because whenever we change the property name through refactoring tools, the string value remains untouched and we have to manually change them as well (if we are lucky enough to get notified before run-time). Anyway we had to tolerate them for years…</p>

<p>C# 5 comes with a nice feature, which is addition of two attributes <code>[CallerFilePath]</code> and <code>[CallerMemberName]</code> in the <code>System.Runtime.CompilerServices</code> namespace. If you decorate an <strong>optional</strong> string parameter of a method with one of these attributes, then the value of that parameter will be replaced with the caller’s file name or the caller’s member name at runtime, if no explicit value is passed for the optional parameter. They come very handy in logging scenarios, but we can use the latter for making our data-binding code nicer. This is how:</p>

<p>```csharp
public class Person : INotifyPropertyChanged
{
    private string _name;
    private double _age;</p>

<pre><code>public string Name 
{
    get
    {
        return _name;
    }

    set
    {
        if (value != _name)
        {
            _name = value;
            OnPropertyChanged();
        }
    }
}

public double Age 
{
    get
    {
        return _age;
    }

    set
    {
        if (_age != value)
        {
            _age = value;
            OnPropertyChanged();
        }
    }
}

public event PropertyChangedEventHandler PropertyChanged;

private void OnPropertyChanged([CallerMemberName]string propertyName = "")
{
    if (PropertyChanged != null)
    {
        PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
    }
} } ```
</code></pre>

<p>Now that string constants are removed from the setters we can more freely refactor our code. After being spoiled by automatic properties, this is still a very verbose way of defining properties; however it is much better than before.</p>
]]></content>
  </entry>
  
</feed>
