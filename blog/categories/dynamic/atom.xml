<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Dynamic | Sina Iravanian]]></title>
  <link href="http://www.sinairv.com/blog/categories/dynamic/atom.xml" rel="self"/>
  <link href="http://www.sinairv.com/"/>
  <updated>2015-01-21T22:31:04+10:00</updated>
  <id>http://www.sinairv.com/</id>
  <author>
    <name><![CDATA[Sina Iravanian]]></name>
    <email><![CDATA[sina.iravanian@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[An Example for C# Dynamic in Action]]></title>
    <link href="http://www.sinairv.com/blog/2012/07/23/an-example-for-c-number-dynamic-in-action/"/>
    <updated>2012-07-23T17:20:53+10:00</updated>
    <id>http://www.sinairv.com/blog/2012/07/23/an-example-for-c-number-dynamic-in-action</id>
    <content type="html"><![CDATA[<p>Recently I was involved with enabling validation for a Windows Forms form containing several pages shown through a tree view. There were one user control defined for each page, therefore whenever a node in tree-view got activated, an instance of that user-control were shown. The user-controls did not have a common user-defined parent base-class or interface. The author of the existing code had defined a <code>Save</code> method in each control separately which performed updating data with values entered in the forms.</p>

<p>First, I changed all <code>void Save()</code> methods to <code>bool Save()</code>, and performed the validation stuff in each control separately. Then in the parent form, I created an array of <code>Control</code>s, so that I could loop through them, and call their <code>Save</code> method. But wait, <code>Save</code> is not inherited from any base-class or interface, so there&rsquo;s no polymorphism at hand. How can I call them through references of type <code>Control</code>?</p>

<p>Well honestly, the best solution would be adding a new interface to the project, say <code>ISavableControl</code> or something, add the <code>Save</code> method to it, and let the controls implement that interface. But I wanted to make a quick fix to the problem without adding new files and types to the code. Here C#&rsquo;s <code>dynamic</code> comes into action.</p>

<p>Using <code>dynamic</code> keyword, one postpones binding methods, properties, and fields to run-time. In our scenario we know that the user-controls each have a method called <code>Save</code>, which is not derived from a parent. Without <code>dynamic</code>, I would need to have a reference explicitly from each user control&rsquo;s type, and I would have to call them one by one, as in:</p>

<p><code>csharp
bool succeeded = false;
succeeded = userControl1.Save();
succeeded = succeeded || userControl2.Save();
succeeded = succeeded || userControl3.Save();
// ...
succeeded = succeeded || userControln.Save();
</code></p>

<p>However using <code>dynamic</code> keyword, life gets a lot easier:</p>

<p>```csharp
// objects are not inherited from a base class or interface,
// therefore we cannot call Save using polymorphism
bool succeeded = false;
foreach(var ctrl in controlsArray)
{
    dynamic dynCtrl = ctrl;
    succeeded = succeeded || dynCtrl.Save();
}</p>

<p>// do something with the value of succeeded
```</p>

<p>Take care that binding the <code>Save</code> methods to controls happen at runtime. Therefore if a control does not implement a <code>Save</code> method, or if another one misspells <code>Save</code>, as say <code>Svae</code>, you will get no hints at compile time. So, try to avoid this style of coding, unless you have good reasons for doing so.</p>
]]></content>
  </entry>
  
</feed>
